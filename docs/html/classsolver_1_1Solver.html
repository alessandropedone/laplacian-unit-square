<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Laplce equation in the unit square: solver::Solver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Laplce equation in the unit square<span id="projectnumber">&#160;v0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesolver.html">solver</a></li><li class="navelem"><a class="el" href="classsolver_1_1Solver.html">Solver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsolver_1_1Solver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">solver::Solver Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A numerical solver class for solving 2D Laplace equations using various iterative and direct methods.  
 <a href="classsolver_1_1Solver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="solver_8hpp_source.html">solver.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad2d98bfe12c49b3bdb4ff6b9de2e2585" id="r_ad2d98bfe12c49b3bdb4ff6b9de2e2585"><td class="memItemLeft" align="right" valign="top"><a id="ad2d98bfe12c49b3bdb4ff6b9de2e2585" name="ad2d98bfe12c49b3bdb4ff6b9de2e2585"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Solver</b> ()=default</td></tr>
<tr class="memdesc:ad2d98bfe12c49b3bdb4ff6b9de2e2585"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor <br /></td></tr>
<tr class="separator:ad2d98bfe12c49b3bdb4ff6b9de2e2585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21988b29554b79df74bff361c0ae688a" id="r_a21988b29554b79df74bff361c0ae688a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#a21988b29554b79df74bff361c0ae688a">Solver</a> (const std::vector&lt; double &gt; &amp;initial_guess, std::function&lt; double(std::vector&lt; double &gt;)&gt; f, std::function&lt; double(std::vector&lt; double &gt;)&gt; top_bc, std::function&lt; double(std::vector&lt; double &gt;)&gt; right_bc, std::function&lt; double(std::vector&lt; double &gt;)&gt; bottom_bc, std::function&lt; double(std::vector&lt; double &gt;)&gt; left_bc, size_t n, unsigned max_iter=1000, double tol=1e-10, std::function&lt; double(std::vector&lt; double &gt;)&gt; uex=nullptr, double L2_error=-1.0)</td></tr>
<tr class="memdesc:a21988b29554b79df74bff361c0ae688a"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <br /></td></tr>
<tr class="separator:a21988b29554b79df74bff361c0ae688a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c4703a0a97eb569438a55d44827393" id="r_af1c4703a0a97eb569438a55d44827393"><td class="memItemLeft" align="right" valign="top"><a id="af1c4703a0a97eb569438a55d44827393" name="af1c4703a0a97eb569438a55d44827393"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~Solver</b> ()=default</td></tr>
<tr class="memdesc:af1c4703a0a97eb569438a55d44827393"><td class="mdescLeft">&#160;</td><td class="mdescRight">default destructor <br /></td></tr>
<tr class="separator:af1c4703a0a97eb569438a55d44827393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08028742e140fc9e303756d5a542148" id="r_aa08028742e140fc9e303756d5a542148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#aa08028742e140fc9e303756d5a542148">solve_jacobi_serial</a> ()</td></tr>
<tr class="memdesc:aa08028742e140fc9e303756d5a542148"><td class="mdescLeft">&#160;</td><td class="mdescRight">implement Jacobi iterative solver for the Laplace equation without parallelism  <br /></td></tr>
<tr class="separator:aa08028742e140fc9e303756d5a542148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e525126b3f10e4b733f0c7ebcdaf5fe" id="r_a9e525126b3f10e4b733f0c7ebcdaf5fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#a9e525126b3f10e4b733f0c7ebcdaf5fe">solve_jacobi_omp</a> ()</td></tr>
<tr class="memdesc:a9e525126b3f10e4b733f0c7ebcdaf5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">implement Jacobi iterative solver for the Laplace equation with OPENMP  <br /></td></tr>
<tr class="separator:a9e525126b3f10e4b733f0c7ebcdaf5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab72d3e185314fe7d592f455e2cb23b7" id="r_aab72d3e185314fe7d592f455e2cb23b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#aab72d3e185314fe7d592f455e2cb23b7">solve_jacobi_mpi</a> ()</td></tr>
<tr class="memdesc:aab72d3e185314fe7d592f455e2cb23b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">implement Jacobi iterative solver for the Laplace equation with MPI  <br /></td></tr>
<tr class="separator:aab72d3e185314fe7d592f455e2cb23b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78345fc2ae0ec87c6e8a9d2cb8e520c" id="r_ae78345fc2ae0ec87c6e8a9d2cb8e520c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#ae78345fc2ae0ec87c6e8a9d2cb8e520c">solve_jacobi_hybrid</a> ()</td></tr>
<tr class="memdesc:ae78345fc2ae0ec87c6e8a9d2cb8e520c"><td class="mdescLeft">&#160;</td><td class="mdescRight">implement Jacobi iterative solver for the Laplace equation with MPI and OpenMP  <br /></td></tr>
<tr class="separator:ae78345fc2ae0ec87c6e8a9d2cb8e520c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546da403ed0dc198c479276afa9b81b7" id="r_a546da403ed0dc198c479276afa9b81b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#a546da403ed0dc198c479276afa9b81b7">solve_direct_mpi</a> ()</td></tr>
<tr class="memdesc:a546da403ed0dc198c479276afa9b81b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schwarz implementation: locally, the equation is solved using Eigen LDLT decomposition.  <br /></td></tr>
<tr class="separator:a546da403ed0dc198c479276afa9b81b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e70f4f88f5be7fd6791ff6602bdf7e4" id="r_a4e70f4f88f5be7fd6791ff6602bdf7e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#a4e70f4f88f5be7fd6791ff6602bdf7e4">set_n</a> (size_t n)</td></tr>
<tr class="memdesc:a4e70f4f88f5be7fd6791ff6602bdf7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">set grid size  <br /></td></tr>
<tr class="separator:a4e70f4f88f5be7fd6791ff6602bdf7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6697b715c95f8fa21f181cede3ebb04a" id="r_a6697b715c95f8fa21f181cede3ebb04a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#a6697b715c95f8fa21f181cede3ebb04a">set_max_iter</a> (size_t max_iter)</td></tr>
<tr class="memdesc:a6697b715c95f8fa21f181cede3ebb04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the number of max iterations  <br /></td></tr>
<tr class="separator:a6697b715c95f8fa21f181cede3ebb04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9179243f526fcff3e26b47d8a7ded37e" id="r_a9179243f526fcff3e26b47d8a7ded37e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#a9179243f526fcff3e26b47d8a7ded37e">set_tol</a> (double tol)</td></tr>
<tr class="memdesc:a9179243f526fcff3e26b47d8a7ded37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the tolerance for convergence  <br /></td></tr>
<tr class="separator:a9179243f526fcff3e26b47d8a7ded37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3f5a68b6576daace0a184152f73298" id="r_adb3f5a68b6576daace0a184152f73298"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#adb3f5a68b6576daace0a184152f73298">set_uex</a> (const std::function&lt; double(std::vector&lt; double &gt;)&gt; &amp;uex)</td></tr>
<tr class="memdesc:adb3f5a68b6576daace0a184152f73298"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the exact solution of the equation  <br /></td></tr>
<tr class="separator:adb3f5a68b6576daace0a184152f73298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8da65ff9031987eb52d921214fa4aa" id="r_aaa8da65ff9031987eb52d921214fa4aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#aaa8da65ff9031987eb52d921214fa4aa">set_initial_guess</a> (const std::vector&lt; double &gt; &amp;initial_guess)</td></tr>
<tr class="memdesc:aaa8da65ff9031987eb52d921214fa4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the initial guess for the solution  <br /></td></tr>
<tr class="separator:aaa8da65ff9031987eb52d921214fa4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c92779928da8cfbfda9a1d4544a0a8a" id="r_a7c92779928da8cfbfda9a1d4544a0a8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#a7c92779928da8cfbfda9a1d4544a0a8a">set_exact_sol</a> (std::function&lt; double(std::vector&lt; double &gt;)&gt; uex)</td></tr>
<tr class="memdesc:a7c92779928da8cfbfda9a1d4544a0a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the exact solution of the equation  <br /></td></tr>
<tr class="separator:a7c92779928da8cfbfda9a1d4544a0a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d0a39085e66d266fb18d95520d1951" id="r_ac9d0a39085e66d266fb18d95520d1951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#ac9d0a39085e66d266fb18d95520d1951">set_f</a> (std::function&lt; double(std::vector&lt; double &gt;)&gt; f)</td></tr>
<tr class="memdesc:ac9d0a39085e66d266fb18d95520d1951"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the right-hand side of the equation  <br /></td></tr>
<tr class="separator:ac9d0a39085e66d266fb18d95520d1951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d24cacc2533fbe10d22bcd7315e1be" id="r_a95d24cacc2533fbe10d22bcd7315e1be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#a95d24cacc2533fbe10d22bcd7315e1be">set_bc</a> (const std::function&lt; double(std::vector&lt; double &gt;)&gt; &amp;top_bc, const std::function&lt; double(std::vector&lt; double &gt;)&gt; &amp;right_bc, const std::function&lt; double(std::vector&lt; double &gt;)&gt; &amp;bottom_bc, const std::function&lt; double(std::vector&lt; double &gt;)&gt; &amp;left_bc)</td></tr>
<tr class="memdesc:a95d24cacc2533fbe10d22bcd7315e1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the boundary conditions of the system  <br /></td></tr>
<tr class="separator:a95d24cacc2533fbe10d22bcd7315e1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9995eb48382d436ce4f954a61403e5e2" id="r_a9995eb48382d436ce4f954a61403e5e2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#a9995eb48382d436ce4f954a61403e5e2">l2_error</a> ()</td></tr>
<tr class="memdesc:a9995eb48382d436ce4f954a61403e5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the L2 error between the computed solution and the exact solution  <br /></td></tr>
<tr class="separator:a9995eb48382d436ce4f954a61403e5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe03390132786d06efe34457a1d9905" id="r_aafe03390132786d06efe34457a1d9905"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#aafe03390132786d06efe34457a1d9905">save_vtk</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:aafe03390132786d06efe34457a1d9905"><td class="mdescLeft">&#160;</td><td class="mdescRight">save the computed solution to a VTK file  <br /></td></tr>
<tr class="separator:aafe03390132786d06efe34457a1d9905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc2a7eb6dec17e82feff03c655cc06a" id="r_acdc2a7eb6dec17e82feff03c655cc06a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#acdc2a7eb6dec17e82feff03c655cc06a">get_iter</a> () const</td></tr>
<tr class="memdesc:acdc2a7eb6dec17e82feff03c655cc06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the number of iterations tracked during the solver  <br /></td></tr>
<tr class="separator:acdc2a7eb6dec17e82feff03c655cc06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c716e21ee3cfb6a225d150df5d3a20" id="r_aa8c716e21ee3cfb6a225d150df5d3a20"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#aa8c716e21ee3cfb6a225d150df5d3a20">get_uh</a> () const</td></tr>
<tr class="memdesc:aa8c716e21ee3cfb6a225d150df5d3a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the computed solution  <br /></td></tr>
<tr class="separator:aa8c716e21ee3cfb6a225d150df5d3a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2789087b356d07393c187ea027f33c6" id="r_aa2789087b356d07393c187ea027f33c6"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#aa2789087b356d07393c187ea027f33c6">get_uex</a> () const</td></tr>
<tr class="memdesc:aa2789087b356d07393c187ea027f33c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the exact solution in vector form  <br /></td></tr>
<tr class="separator:aa2789087b356d07393c187ea027f33c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcc88ebda577ad17e592882c630aeb7" id="r_abbcc88ebda577ad17e592882c630aeb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Solver.html#abbcc88ebda577ad17e592882c630aeb7">reset</a> ()</td></tr>
<tr class="memdesc:abbcc88ebda577ad17e592882c630aeb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the solver  <br /></td></tr>
<tr class="separator:abbcc88ebda577ad17e592882c630aeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A numerical solver class for solving 2D Laplace equations using various iterative and direct methods. </p>
<p>This class provides multiple implementation approaches for solving the 2D Laplace equation:</p><ul>
<li>Serial Jacobi iteration</li>
<li>OpenMP parallel Jacobi iteration</li>
<li>MPI parallel Jacobi iteration</li>
<li>Hybrid MPI+OpenMP Jacobi iteration</li>
<li>Direct MPI solver using Schwarz domain decomposition</li>
</ul>
<p>The solver operates on a square grid of size n×n and supports:</p><ul>
<li>Custom boundary conditions on all four sides</li>
<li>Custom right-hand side forcing functions</li>
<li>Convergence checking with configurable tolerance</li>
<li>Error computation when exact solution is known</li>
<li><p class="startli">VTK output for visualization</p>
<p class="startli">The class uses function objects to define boundary conditions, forcing terms, and exact solutions, providing flexibility in problem specification. All parallel implementations use appropriate synchronization mechanisms to ensure correctness and convergence checking.</p>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Grid coordinates are normalized to [0,1]×[0,1] domain. Function arguments are passed as std::vector&lt;double&gt; containing {x, y} coordinates. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a21988b29554b79df74bff361c0ae688a" name="a21988b29554b79df74bff361c0ae688a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21988b29554b79df74bff361c0ae688a">&#9670;&#160;</a></span>Solver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">solver::Solver::Solver </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(std::vector&lt; double &gt;)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(std::vector&lt; double &gt;)&gt;&#160;</td>
          <td class="paramname"><em>top_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(std::vector&lt; double &gt;)&gt;&#160;</td>
          <td class="paramname"><em>right_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(std::vector&lt; double &gt;)&gt;&#160;</td>
          <td class="paramname"><em>bottom_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(std::vector&lt; double &gt;)&gt;&#160;</td>
          <td class="paramname"><em>left_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(std::vector&lt; double &gt;)&gt;&#160;</td>
          <td class="paramname"><em>uex</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>L2_error</em> = <code>-1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uex</td><td>exact solution of the equation </td></tr>
    <tr><td class="paramname">initial_guess</td><td>initial guess for the solution </td></tr>
    <tr><td class="paramname">f</td><td>right-hand side of the equation </td></tr>
    <tr><td class="paramname">top_bc</td><td>top boundary condition </td></tr>
    <tr><td class="paramname">right_bc</td><td>right boundary condition </td></tr>
    <tr><td class="paramname">bottom_bc</td><td>bottom boundary condition </td></tr>
    <tr><td class="paramname">left_bc</td><td>left boundary condition </td></tr>
    <tr><td class="paramname">n</td><td>grid size </td></tr>
    <tr><td class="paramname">max_iter</td><td>maximum number of iterations </td></tr>
    <tr><td class="paramname">tol</td><td>tolerance for convergence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acdc2a7eb6dec17e82feff03c655cc06a" name="acdc2a7eb6dec17e82feff03c655cc06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc2a7eb6dec17e82feff03c655cc06a">&#9670;&#160;</a></span>get_iter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned solver::Solver::get_iter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the number of iterations tracked during the solver </p>
<dl class="section return"><dt>Returns</dt><dd>number of iterations </dd></dl>

</div>
</div>
<a id="aa2789087b356d07393c187ea027f33c6" name="aa2789087b356d07393c187ea027f33c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2789087b356d07393c187ea027f33c6">&#9670;&#160;</a></span>get_uex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; solver::Solver::get_uex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the exact solution in vector form </p>
<dl class="section return"><dt>Returns</dt><dd>exact solution </dd></dl>

</div>
</div>
<a id="aa8c716e21ee3cfb6a225d150df5d3a20" name="aa8c716e21ee3cfb6a225d150df5d3a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c716e21ee3cfb6a225d150df5d3a20">&#9670;&#160;</a></span>get_uh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; solver::Solver::get_uh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the computed solution </p>
<dl class="section return"><dt>Returns</dt><dd>computed solution </dd></dl>

</div>
</div>
<a id="a9995eb48382d436ce4f954a61403e5e2" name="a9995eb48382d436ce4f954a61403e5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9995eb48382d436ce4f954a61403e5e2">&#9670;&#160;</a></span>l2_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double solver::Solver::l2_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the L2 error between the computed solution and the exact solution </p>
<dl class="section return"><dt>Returns</dt><dd>L2 error</dd></dl>
<p>The L2 error is computed as the square root of the sum of the squares of the differences between the computed solution and the exact solution</p>
<p>The L2 error is used to measure the accuracy of the computed solution</p>
<p>The L2 error is computed only if the exact solution is known </p>

</div>
</div>
<a id="abbcc88ebda577ad17e592882c630aeb7" name="abbcc88ebda577ad17e592882c630aeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcc88ebda577ad17e592882c630aeb7">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Solver::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reset the solver </p>
<p>The reset function clears the solution vector and resets the number of iterations to zero</p>
<p>The reset function is used to reinitialize the solver before starting a new computation </p>

</div>
</div>
<a id="aafe03390132786d06efe34457a1d9905" name="aafe03390132786d06efe34457a1d9905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe03390132786d06efe34457a1d9905">&#9670;&#160;</a></span>save_vtk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Solver::save_vtk </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>save the computed solution to a VTK file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of the output file</td></tr>
  </table>
  </dd>
</dl>
<p>The computed solution is saved in a VTK file format </p>

</div>
</div>
<a id="a95d24cacc2533fbe10d22bcd7315e1be" name="a95d24cacc2533fbe10d22bcd7315e1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d24cacc2533fbe10d22bcd7315e1be">&#9670;&#160;</a></span>set_bc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Solver::set_bc </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; double(std::vector&lt; double &gt;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>top_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; double(std::vector&lt; double &gt;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>right_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; double(std::vector&lt; double &gt;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>bottom_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; double(std::vector&lt; double &gt;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>left_bc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the boundary conditions of the system </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top_bc</td><td>top boundary condition </td></tr>
    <tr><td class="paramname">right_bc</td><td>right boundary condition </td></tr>
    <tr><td class="paramname">bottom_bc</td><td>bottom boundary condition </td></tr>
    <tr><td class="paramname">left_bc</td><td>left boundary condition</td></tr>
  </table>
  </dd>
</dl>
<p>The boundary conditions are defined as functions of two variables and are used to set the values of the solution at the boundaries </p>

</div>
</div>
<a id="a7c92779928da8cfbfda9a1d4544a0a8a" name="a7c92779928da8cfbfda9a1d4544a0a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c92779928da8cfbfda9a1d4544a0a8a">&#9670;&#160;</a></span>set_exact_sol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Solver::set_exact_sol </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; double(std::vector&lt; double &gt;)&gt;&#160;</td>
          <td class="paramname"><em>uex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the exact solution of the equation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exact_sol</td><td>exact solution of the equation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9d0a39085e66d266fb18d95520d1951" name="ac9d0a39085e66d266fb18d95520d1951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d0a39085e66d266fb18d95520d1951">&#9670;&#160;</a></span>set_f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Solver::set_f </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; double(std::vector&lt; double &gt;)&gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the right-hand side of the equation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>right-hand side of the equation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa8da65ff9031987eb52d921214fa4aa" name="aaa8da65ff9031987eb52d921214fa4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8da65ff9031987eb52d921214fa4aa">&#9670;&#160;</a></span>set_initial_guess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Solver::set_initial_guess </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_guess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the initial guess for the solution </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_guess</td><td>initial guess for the solution</td></tr>
  </table>
  </dd>
</dl>
<p>The initial guess is used to initialize the solution vector before the iterative solver starts </p>

</div>
</div>
<a id="a6697b715c95f8fa21f181cede3ebb04a" name="a6697b715c95f8fa21f181cede3ebb04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6697b715c95f8fa21f181cede3ebb04a">&#9670;&#160;</a></span>set_max_iter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Solver::set_max_iter </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the number of max iterations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_iter</td><td>maximum number of iterations</td></tr>
  </table>
  </dd>
</dl>
<p>The maximum number of iterations is used to limit the number of iterations in the iterative solver </p>

</div>
</div>
<a id="a4e70f4f88f5be7fd6791ff6602bdf7e4" name="a4e70f4f88f5be7fd6791ff6602bdf7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e70f4f88f5be7fd6791ff6602bdf7e4">&#9670;&#160;</a></span>set_n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Solver::set_n </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set grid size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>grid size</td></tr>
  </table>
  </dd>
</dl>
<p>The grid size is used to define the number of grid points and the size of the solution vector </p>

</div>
</div>
<a id="a9179243f526fcff3e26b47d8a7ded37e" name="a9179243f526fcff3e26b47d8a7ded37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9179243f526fcff3e26b47d8a7ded37e">&#9670;&#160;</a></span>set_tol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Solver::set_tol </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the tolerance for convergence </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tol</td><td>tolerance for convergence</td></tr>
  </table>
  </dd>
</dl>
<p>The tolerance is used to check the convergence of the iterative solver. If the residual is less than the tolerance, the solver is considered to have converged </p>

</div>
</div>
<a id="adb3f5a68b6576daace0a184152f73298" name="adb3f5a68b6576daace0a184152f73298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3f5a68b6576daace0a184152f73298">&#9670;&#160;</a></span>set_uex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Solver::set_uex </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; double(std::vector&lt; double &gt;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>uex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the exact solution of the equation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uex</td><td>exact solution of the equation</td></tr>
  </table>
  </dd>
</dl>
<p>The exact solution is used to compare the computed solution and to compute the error of the computed solution </p>

</div>
</div>
<a id="a546da403ed0dc198c479276afa9b81b7" name="a546da403ed0dc198c479276afa9b81b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546da403ed0dc198c479276afa9b81b7">&#9670;&#160;</a></span>solve_direct_mpi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Solver::solve_direct_mpi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schwarz implementation: locally, the equation is solved using Eigen LDLT decomposition. </p>
<p>for each processor, it computes the local solution of the equation using a direct method and checks for convergence using the L2 norm</p>
<p>it uses Eigen's SparseMatrix and SimplicialLDLT to solve the local system</p>
<p>it uses MPI to divide the domain among the processes </p>

</div>
</div>
<a id="ae78345fc2ae0ec87c6e8a9d2cb8e520c" name="ae78345fc2ae0ec87c6e8a9d2cb8e520c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78345fc2ae0ec87c6e8a9d2cb8e520c">&#9670;&#160;</a></span>solve_jacobi_hybrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Solver::solve_jacobi_hybrid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>implement Jacobi iterative solver for the Laplace equation with MPI and OpenMP </p>
<p>it computes the solution of the equation using the Jacobi method and checks for convergence using the L2 norm</p>
<p>it saves the solution in the uh vector and writes it to an output vtk file</p>
<p>it uses hybrid parallelism with MPI and OpenMP </p>

</div>
</div>
<a id="aab72d3e185314fe7d592f455e2cb23b7" name="aab72d3e185314fe7d592f455e2cb23b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab72d3e185314fe7d592f455e2cb23b7">&#9670;&#160;</a></span>solve_jacobi_mpi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Solver::solve_jacobi_mpi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>implement Jacobi iterative solver for the Laplace equation with MPI </p>
<p>it computes the solution of the equation using the Jacobi method and checks for convergence using the L2 norm</p>
<p>it saves the solution in the uh vector and writes it to an output vtk file</p>
<p>it uses MPI to parallelize the computation of the solution </p>

</div>
</div>
<a id="a9e525126b3f10e4b733f0c7ebcdaf5fe" name="a9e525126b3f10e4b733f0c7ebcdaf5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e525126b3f10e4b733f0c7ebcdaf5fe">&#9670;&#160;</a></span>solve_jacobi_omp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Solver::solve_jacobi_omp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>implement Jacobi iterative solver for the Laplace equation with OPENMP </p>
<p>it computes the solution of the equation using the Jacobi method and checks for convergence using the L2 norm</p>
<p>it saves the solution in the uh vector and writes it to an output vtk file</p>
<p>it uses OpenMP to parallelize the computation of the solution</p>
<p>it uses a static schedule to distribute the work among threads</p>
<p>it uses a barrier to synchronize the threads before checking for convergence</p>
<p>it uses a single directive to update the previous solution vector</p>
<p>it uses a collapse directive to parallelize the nested loops </p>

</div>
</div>
<a id="aa08028742e140fc9e303756d5a542148" name="aa08028742e140fc9e303756d5a542148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08028742e140fc9e303756d5a542148">&#9670;&#160;</a></span>solve_jacobi_serial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Solver::solve_jacobi_serial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>implement Jacobi iterative solver for the Laplace equation without parallelism </p>
<p>it computes the solution of the equation using the Jacobi method and checks for convergence using the L2 norm</p>
<p>it saves the solution in the uh vector and writes it to an output vtk file </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/ale/challenge3-male/include/core/<a class="el" href="solver_8hpp_source.html">solver.hpp</a></li>
<li>/home/ale/challenge3-male/src/<a class="el" href="solver_8cpp.html">solver.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
